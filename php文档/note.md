## 面向对象编程
面向对象专注于由哪个对象来处理一个问题，其最大特点是由一个一个具有属性和功能的类，从类中拿到对象，进而处理问题。
### 类
具有相同属性（特征）和方法（行为）的一系列个体的集合，类是一个抽象的概念
#### 对象
从类中，拿到的具有具体属性值的个体，称为对象。对象是一个具体的个体
#### 类和对象关系
类是对象的抽象化！对象是类的具体化！类仅仅表明这类对象有哪些属性，但是不能有具体的值，所以类是抽象的；对象是将类的所有属性赋值后，产生具体的个体，所有对象是具体的。
#### 魔术方法
- __construct():构造函数，new一个对象时，自动调用。
- __destruct():析构函数，当一个对象被销毁前，自动调用。
- __get():访问类中私有属性时，自动调用。传递读取的属性名，返回$this->属性名
- __set():给类的私有属性赋值时，自动调用。传递需要设置的属性名和属性值；
- __isset():使用isset()检测对象私有属性时，自动调用。传递检测的属性名，返回isset($this -> 属性名);
- __unset():使用unset()删除对象私有属性时，自动调用。传递删除的属性名，方法中执行unset($this -> 属性名);
- __toString():使用echo打印对象时，自动调用。返回想要在打印对象时，显示的内容；返回必须是字符串；
- __call():调用一个类中未定义或未公开的方法时，自动调用。传递被调用的函数名，和参数列表数组；
- __clone():当使用clone关键字，克隆一个对象时，自动调用。作用是为新克隆的对象进行初始化赋值；
- __sleep():对象序列化时，自动调用。返回一个数组，数组中的值就是可以序列化的属性；
- __wakeup():对象反序列化时，自动调用。为反序列化新产生的对象，进行初始化赋值；
- __autoload():需要在类外部声明函数。当实例化一个未声明的类时，自动调用。传递实例化的类名，可以使用类名自动加载对应的类文件。
### 抽象类&方法
- 没有方法体{}的方法，必须使用abstract关键字修饰：abstract function say();
- 使用abstract关键字修饰：abstract class Person{}
##### 说明
- 抽象类可以包含非抽象方法
- 包含抽象方法的类必须是抽象类，抽象类并不一定必须包含抽象方法
- 抽象类，不能实例化。（抽象类中可能包含抽象方法，抽象方法没有方法体，实例化调用没有意义）
- 我们使用抽象类的目的，就是限制实例化
- 子类继承抽象类，那么子类必须重写父类的所有抽象方法，除非，子类也是抽象类
#### 使用抽象类的作用
- 限制实例化。（抽象类是一个不完整的类，里面的抽象方法没有方法体，所以不能实例化）
- 抽象类为子类的继承提供一种规范，子类继承一个抽象类，则必须包含并且实现抽象类中已定的抽象方法。
### 接口
接口是一种规范，提供了一组实现接口的类所必须实现的方法组合。
接口使用interface关键字声明；
interface Inter{}

#### 说明
- 接口中的所有方法，必须都是抽象方法（接口中的抽象方法不需要也不能使用abstract修饰）
- 接口中不能声明变量，不能有属性，只能使用常量
- 接口可以继承接口，使用extends关键字
- 接口使用extends继承接口，可以实现多继承。interface int3 extends Inter1,Inter2{}
- 类可以实现接口，使用implements关键字（类使用implements实现接口，可同时实现多个接口，多个接口间逗号分隔，abstract class Person implements Inter,Inter2{}）
- 一个类实现一个或多个接口，那么这个类，必须实现所有接口中的所有抽象方法！
- 除非，这个类是抽象类

### 接口&&抽象类区别
- 声明方式上，接口使用interface关键字，抽象类使用abstract class
- 实现/继承方式上，一个类使用extends继承抽象类，使用implements实现接口
- 抽象类只能单继承，接口可以多实现。（接口extends接口）、多实现（类implements接口1,接口2）
- 抽象类中可以有非抽象方法，接口中只能有抽象方法，不能有费抽象方法。抽象类中的抽象方法必须使用abstract关键字修饰，接口中抽象方法不能带修饰词
- 抽象类是个类，可以有属性、变量；接口中只能有常量。

### 多态
一个类，被多个子类继承(这个类的某个方法，在多个子类中，表现出不同的功能，即称为多态)
#### 实现多态的必要途径
- 子类继承父类
- 子类重写父类方法
- 父类引用指向子类对象



## MySQL 优化
> 优化顺序，最低成本！
1. 优化你的sql和索引
2. 加缓存，memcached,redis
3. 读写分离，可以在应用层做，效率高
4. 还是慢，不要想着去做切分，mysql自带分区表
5. 如果以上都做了，那就先做垂直拆分，其实就是根据你模块的耦合度，将一个大的系统分为多个小的系统，也就是分布式系统
6. 第六才是水平切分，针对数据量大的表，这一步最麻烦，最能考验技术水平，要选择一个合理的sharding key,为了有好的查询效率，表结构也要改动，做一定的冗余，应用也要改，sql中尽量带sharding key，将数据定位到限定的表上去查，而不是扫描全部的表


#### 例子，亿级表
- 方案一：优化现有mysql数据库。优点：不影响现有业务，源程序不需要修改代码，成本最低。缺点：有优化瓶颈，数据量过亿就玩完了。 
- 方案二：升级数据库类型，换一种100%兼容mysql的数据库。优点：不影响现有业务，源程序不需要修改代码，你几乎不需要做任何操作就能提升数据库性能，缺点：多花钱 
- 方案三：一步到位，大数据解决方案，更换newsql/nosql数据库。优点：没有数据容量瓶颈，缺点：需要修改源程序代码，影响业务，总成本最高。以上三种方案，按顺序使用即可，数据量在亿级别一下的没必要换nosql，开发成本太高。三种方案我都试了一遍，而且都形成了落地解决方案。该过程心中慰问跑路的那几个开发者一万遍 :)

**表字段避免null值出现，null值很难查询优化且占用额外的索引空间，推荐默认0或 ''代替null**

### 分库分表,应该最后考虑
很明显，一个主表（也就是很重要的表，例如用户表）无限制的增长势必严重影响性能，分库与分表是一个很不错的解决途径，也就是性能优化途径，现在的案例是我们有一个1000多万条记录的用户表members,查询起来非常之慢，同事的做法是将其散列到100个表中，分别从members0到members99，然后根据mid分发记录到这些表中，牛逼的代码大概是这样子：
复制代码代码如下:

```php
<?php
for($i=0;$i< 100; $i++ ){
//echo "CREATE TABLE db2.members{$i} LIKE db1.members<br>";
echo "INSERT INTO members{$i} SELECT * FROM members WHERE mid%100={$i}<br>";
}
?>
```


2、不停机修改mysql表结构

同样还是members表，前期设计的表结构不尽合理，随着数据库不断运行，其冗余数据也是增长巨大，同事使用了下面的方法来处理：

先创建一个临时表：
```sql
CREATE TABLE members_tmp LIKE members;
```
然后修改members_tmp的表结构为新结构，接着使用上面那个for循环来导出数据，因为1000万的数据一次性导出是不对的，mid是主键，一个区间一个区间的导，基本是一次导出5万条吧，这里略去了
接着重命名将新表替换上去：


```sql
# 这是个颇为经典的语句
RENAME TABLE members TO members_bak,members_tmp TO members;
```

就是这样，基本可以做到无损失，无需停机更新表结构，但实际上RENAME期间表是被锁死的，所以选择在线少的时候操作是一个技巧。经过这个操作，使得原先8G多的表，一下子变成了2G多

