ftfyuguihiughiuguiffhfjyf.guhinlkhihyfyd'sa'd'sa'da's 打算打算
在事务中，每个正确的原子操作都会被顺序执行，直到遇到错误的原子操作，此时事务会将之前的操作进行回滚。回滚的意思是如果之前是插入操作，那么会执行删 除插入的记录，如果之前是update操作，也会执行update操作将之前的记录还原

因此，正确的原子操作是真正被执行过的。是物理执行。

在当前事务中确实能看到插入的记录。最后只不过删除了。但是AUTO_INCREMENT不会应删除而改变值。

1、为什么auto_increament没有回滚？

因为innodb的auto_increament的计数器记录的当前值是保存在存内存中的，并不是存在于磁盘上，当mysql server处于运行的时候，这个计数值只会随着insert改增长，不会随着delete而减少。而当mysql server启动时，当我们需要去查询auto_increment计数值时，mysql便会自动执行：SELECT MAX(id) FROM 表名 FOR UPDATE;语句来获得当前auto_increment列的最大值，然后将这个值放到auto_increment计数器中。所以就算 Rollback MySQL的auto_increament计数器也不会作负运算。

2、MySQL的事务对表操作的时候是否是物理操作？

MySQL的事务是有redo和undo的，redo操作的所有信息都是记录到 redo_log中，也就是说当一个事务做commit操作时，需要先把这个事务的操作写到redo_log中，然后再把这些操作flush到磁盘上，当 出现故障时，只需要读取redo_log,然后再重新flush到磁盘就行了。

而对于undo就比较麻烦，MySQL在处理事务时，会在数据共享 表空间里申请一个段叫做segment段，用保存undo信息，当在处理rollback，不是完完全全的物理undo，而是逻辑undo,就是说会对之 前的操作进行反操作，但是这些共享表空间是不进行回收的。这些表空间的回收需要由mysql的master thread进程来进行回收。


---------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------

mysql事务是指将数据库从一种一致性状态转到另一种一致性状态

mysql事务具有ACID特性：

原子性（Atomicity）：事务中的所有操作，要么全部执行，要么都不执行
一致性（Consistency）：事务开始和结束后，数据库的完整性不会被破坏
隔离性（Isolation）：事务之间互不影响。事务的隔离级别有四种：读未提交、读已提交、可重复读（默认隔离级别）、串行化
持久性（Durability）：事务提交后，对数据的修改是永久性的，即使系统故障也不会丢失
mysql事务的隔离级别

读未提交（read uncommited）：即事务对数据库数据所做的修改，在事务未提交之前，可以被其他事务看到。A事务对数据库数据做的修改，在A事务未提交时，事务B可读到A事务对数据所做的修改。
容易产生的问题：脏读。由于事务B可读到事务A所做的修改，但是A并没有提交，如果事务A执行过程中发生异常回滚，则会导致事务B读到的是错误数据，即脏数据

读已提交（read commited）：A、B两个数据同时对数据库中同一条数据做修改，A事务开启，读取数据，此时，B事务也开启，读取数据，并对数据做出修改，然后提交，此时事务A继续执行，执行完后，再次读取数据，发现两次读取的结果不一样，由此产生不可重复读的问题。

可重复读（repeatable read）：A事务读取数据库数据，在处理业务的过程中事务B读取数据并修改完成后，事务A再次读取数据时，所得结果和之前读取的数据一致，并且事务A提交后，不会损害数据的一致性。可能产生的问题：幻读。如：事务A开启，读取用户x的age为15，B事务开启age读取用户x的age并加1，此时用户x的age为16，A事务继续执行，将用户x的age加1，提交后，发现x用户的age值为17.从用户的角度来看，数据的一致性并没有被破坏，但A事务可能将读取到的数据15返回给用户，导致幻读。

串行化（serializable）：表上的一个事务开启后，在该事务提交之前，其他事务不能对表中的数据做任何修改。该隔离级别会锁表。


